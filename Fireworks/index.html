<!doctype html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Blow shit up</title>
	<style>
		body{
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}
		#container {
			background: #000;
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body>

	<div id="container">


	</div>

</body>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="js/Three.js"></script>

<script type="text/javascript">
	
	// @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame       || 
		window.webkitRequestAnimationFrame || 
		window.mozRequestAnimationFrame    || 
		window.oRequestAnimationFrame      || 
		window.msRequestAnimationFrame     || 
		function(/* function */ callback, /* DOMElement */ element){
			window.setTimeout(callback, 1000 / 60);
		};
	})();
	// set the scene size
	var WIDTH = window.innerWidth,
	HEIGHT = window.innerHeight;
	
	// set some camera attributes
	var VIEW_ANGLE = 90,
	ASPECT = WIDTH / HEIGHT,
	NEAR = 0.1,
	FAR = 10000;

	var particleSystem;
	var particle;
	var particleCount = 100;
	var is_explosion = false;

	var flares = [];
	var fcount = 0; 
	var flareVelocity = 0.10;
	

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#container');
	
	// create a WebGL renderer, camera
	// and a scene
	var renderer = new THREE.WebGLRenderer();
	var camera = new THREE.Camera(  VIEW_ANGLE,
		ASPECT,
		NEAR,
		FAR  );
	var scene = new THREE.Scene();
	
	camera.position.z = 300;
	renderer.setClearColor(new THREE.Color(0, 1));
	renderer.setSize(WIDTH, HEIGHT);
	$container.append(renderer.domElement);
	
	initParticle();
	spawnParticles();

	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	window.addEventListener( 'resize', onWindowResize, false );


	function onDocumentMouseDown( event ) {

		mouseX = (event.clientX);
		mouseY = (event.clientY);
		console.log(mouseX);
		initExplosion();

		
		console.log(fcount);
	}

	function onWindowResize( e ) {
		WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


	
	// animation loop
	function update() {
		
		if(is_explosion){
			pCount = particleCount;
			while(pCount--){
				particle = particles.vertices[pCount];
				particle.velocity.y -= Math.random() * .01;

				particle.position.addSelf(
				particle.velocity);
			}

			initFlare();
			spawnFlares();
		}


		if(true){
			pCount = particleCount;
			while(pCount--){
				for(var c = 0; c < fcount; c++){
					flare = flares[c].vertices[pCount];
					flare.velocity.y -= Math.random() * .01;

					flare.position.addSelf(
					flare.velocity);
				}
				

			}
		}



		//particleSystem.geometry.__dirtyVertices = true;
		renderer.render(scene, camera);

		requestAnimFrame(update);
	}





	function initParticle(){

		particles = new THREE.Geometry(),
		pMaterial = new THREE.ParticleBasicMaterial({
			color: 0xFFFFFF,
			size: 10,
			map: THREE.ImageUtils.loadTexture(
				"images/particle.png"
				),
			blending: THREE.AdditiveBlending,
			transparent: true,
			opacity: 0.5
		});

		for(var p = 0; p < particleCount; p++) {

			particle = new THREE.Vertex(
				new THREE.Vector3(0, 0, 0)
				);

			particle.velocity = new THREE.Vector3(0,0,0);
			particles.vertices.push(particle);
		}
	}

	function initFlare(){

		

		flares[fcount] = new THREE.Geometry(),
		pMaterial = new THREE.ParticleBasicMaterial({
			color: 0xFFFFFF,
			size: 10,
			map: THREE.ImageUtils.loadTexture(
				"images/particle.png"
				),
			blending: THREE.AdditiveBlending,
			transparent: true,
			opacity: 0.1,
			depthTest: false

		});
		
		// now create the individual particles
		pCount = particleCount;
		
		while(pCount--){
			particle = particles.vertices[pCount];

			var pX = particle.position.x,
			pY = particle.position.y,
			pZ = particle.position.z,
			flare = new THREE.Vertex(
				new THREE.Vector3(pX, pY, pZ)
				);
			// create a velocity vector

			flare.velocity = new THREE.Vector3(
			(Math.random() - 0.5)*flareVelocity,
			(Math.random() - 0.5)*flareVelocity,
			(Math.random() - 0.5)*flareVelocity);

			// add it to the geometry
			flares[fcount].vertices.push(flare);

		}


			
		
	}

	function spawnParticles(){

		var particleSystem = new THREE.ParticleSystem(
			particles,
			pMaterial);

		particleSystem.sortParticles = true;
		scene.addChild(particleSystem);
	}

	function initExplosion(){

		is_explosion = true;
		xPos = (Math.random() - 0.5)*200;
		yPos = (Math.random() - 0.5)*200;

		for(var p = 0; p < particleCount; p++) {
			particle = particles.vertices[p];

			particle.position.x = xPos;
			particle.position.y = yPos;
			particle.position.z = 0;

			particle.velocity = new THREE.Vector3(
			Math.random() - 0.5,
			Math.random() - 0.5,
			Math.random() - 0.5);

		}	
	}

	function spawnFlares(){

		
		
		// create the particle system
		var flareSystem = new THREE.ParticleSystem(
			flares[fcount],
			pMaterial);
		
		flareSystem.sortParticles = true;
		
		// add it to the scene
		scene.addChild(flareSystem);

		fcount+=1;

	}


requestAnimFrame(update);
</script>
</html>